\chapter{Fundamentação teórica}\label{cap:revisao}

Nesta seção será discutido o funcionamento e as principais características do
LZ77, com o propósito de permitir ao leitor uma
melhor compreensão dos algoritmos utilizados neste trabalho.

\section{Funcionamento do LZ77}\label{sec:LZ77}

O algoritmo de compressão LZ77, proposto por Ziv e Lempel em
1977~\cite{1055714}, pertence à classe dos métodos baseados em dicionário.
Sua principal característica é o uso de uma \textbf{janela deslizante} de
comprimento fixo \(W\), que percorre sequencialmente a entrada e permite
substituir repetições por referências a ocorrências anteriores.

\subsection{Estrutura da janela deslizante}

A janela deslizante possui comprimento total \(W\) e é dividida em duas
partes:

\begin{itemize}
  \item \textbf{\textit{Search buffer}} — de comprimento \(S\): contém a porção
        da sequência já processada, isto é, o passado disponível para referência;
  \item \textbf{\textit{Lookahead buffer}} — de comprimento \(L\): contém os
        próximos símbolos a serem codificados, representando o futuro imediato;
\end{itemize}

de modo que:
\[
  W = S + L.
\]

Esses três parâmetros (\(W\), \(S\), \(L\)) são comprimentos
relevantes para o funcionamento do algoritmo. \(W\) determina o tamanho da
janela total, \(S\) limita o histórico de busca, e \(L\) define o tamanho máximo
de sequência a ser codificada em um único passo.

\subsection{Formação dos tokens}

Durante a codificação, o algoritmo busca no \textit{search buffer} o maior 
prefixo, sendo a maior sequecia de caracteres iguais, que ocorra dentro do \textit{lookahead buffer}. O resultado dessa
busca é codificado como um \textbf{token}
\(\langle p, \ell, x \rangle\), onde:

\begin{itemize}
  \item \(p\) (\textit{pointer}) é a posição, contada a partir do \textbf{início}
        do \textit{search buffer}, em que ocorre a correspondência mais longa;
  \item \(\ell\) (\textit{length}) é o comprimento da sequência coincidente, com
        \(0 \leq \ell \leq L\);
  \item \(x \in \mathcal{X}\) é o próximo símbolo literal, que segue a sequência
        copiada e garante a continuidade da decodificação.
\end{itemize}

A saída do codificador é, portanto, uma sequência de tokens
\(\langle p_i, \ell_i, x_i \rangle\), que representam os fatores sucessivos do
texto de entrada.

\paragraph*{Origem do ponteiro.}
Seguindo a convenção do artigo original de Ziv e Lempel~\cite{1055714}, o
ponteiro \(p\) é medido a partir do \textbf{início} do \textit{search buffer}.
Essa escolha difere de algumas implementações posteriores, nas quais \(p\) é
medido a partir do \textbf{fim} do buffer, mas ambas produzem resultados
equivalentes.

A Figura~\ref{fig:Diagrama LZ77} ilustra a estrutura da janela deslizante e o
processo de busca pelo maior prefixo coincidente.

\begin{figure}[ht]
  \centering
  \caption{Divisão da janela deslizante no algoritmo LZ77.}
  \label{fig:Diagrama LZ77}
  \includegraphics[width=12cm]{figuras/DiagramasTCC-LZ77-template}
  \fonte{Adaptada de \textcite{sayood2012introduction}.}
\end{figure}

\subsection{Codificação e exemplo}

O processo de codificação pode ser descrito como:

\begin{enumerate}
  \item Identificar no \textit{search buffer} o maior trecho que coincide com o
        início do \textit{lookahead buffer};
  \item Gerar o token \(\langle p, \ell, x \rangle\), em que \(x\) é o próximo
        símbolo literal após a correspondência;
  \item Avançar a janela em \(\ell + 1\) posições e repetir o processo.
\end{enumerate}

Como exemplo, considere a sequência \texttt{"cabracadabrarrarrad"},
com parâmetros \(W = 13\) e \(L = 6\). O \textit{search buffer} inicial contém
\texttt{"cabraca"}. O primeiro caractere a ser codificado é \texttt{"d"}, para o
qual não há correspondência anterior, resultando no token
\(\langle 6, 0, \texttt{d} \rangle\). Após o avanço da janela, o algoritmo
encontra no histórico a sequência \texttt{"abra"}, gerando o token
\(\langle 0, 4, \texttt{r} \rangle\), e assim sucessivamente.

Durante a decodificação, cada token é expandido de acordo com \(p\) e \(\ell\),
copiando o trecho correspondente do histórico decodificado e adicionando o
símbolo literal \(x\). Dessa forma, o processo é perfeitamente reversível e sem
perdas.

% Aqui
\subsection{Exemplo de Codificação com LZ77}\label{sec:LZ77_exemplo}

Nesta seção será demonstrado um exemplo detalhado do funcionamento da janela
deslizante e da representação do token $\langle p, \ell, x \rangle$ utilizados
pelo algoritmo LZ77. 

A sequência a ser codificada é \texttt{"cabracadabrarrarrad"}. Para este exemplo, a janela deslizante possui
um tamanho total fixo de 13 caracteres, com o \textit{lookahead buffer}
definido em 6 caracteres e search buffer de 7 caracteres. O estado inicial da janela pode ser visto na
Figura~\ref{fig:Estado_0_LZ77}.

\begin{figure}[htp]
  \centering
  \caption{Estado inicial da janela deslizante no algoritmo LZ77}
  \label{fig:Estado_0_LZ77}
  \includegraphics[width=15cm]{figuras/DiagramasTCC-LZ77-Estado-0.pdf}
  \fonte{Adaptada de \textcite{sayood2012introduction}}
\end{figure}

Inicialmente, busca-se no \textit{search buffer} , da esquerda para direita, algum caractere ou sequência
que coincida com o início do \textit{lookahead buffer}. Neste momento,
deseja-se codificar o primeiro caractere do \textit{lookahead buffer}, que é
\texttt{"d"}. Ao observar o \textit{search buffer}, verifica-se que não há
nenhuma correspondência prévia para este caractere. Portanto, o algoritmo gera
o token $\langle 6, 0, \texttt{d} \rangle$, indicando que não houve
correspondência, apesar de o pointer ser 6, o comprimento da sequência
 é 0, assim não fazendo a diferença na codificação, pois não existe cópia sendo feita.

Após esta codificação inicial, a janela deslizante avança uma posição, o que
altera o conteúdo tanto do \textit{search buffer} quanto do \textit{lookahead
  buffer}, conforme mostrado na Figura~\ref{fig:Estado_1_LZ77}.

\begin{figure}[htp]
  \centering
  \caption{Estado da janela após primeira codificação no algoritmo LZ77}
  \label{fig:Estado_1_LZ77}
  \includegraphics[width=15cm]{figuras/DiagramasTCC-LZ77-Estado-1.pdf}
  \fonte{Adaptada de \textcite{sayood2012introduction}}
\end{figure}

Nesse novo estado, procura-se novamente uma correspondência no \textit{search
  buffer} para a sequência do \textit{lookahead buffer}, que agora começa com
\texttt{"a"}. Observando o \textit{search buffer}, é possível encontrar
múltiplas ocorrências isoladas do caractere \texttt{"a"}, próximo a esquerda. Notavelmente, existe uma
sequência completa \texttt{"abra"} previamente codificada, iniciando a
0~caracteres de distância da posição atual da janela. Essa correspondência
possui comprimento 4~caracteres.

Dessa forma, o algoritmo codifica a sequência encontrada como o token $\langle
  0, 4, \texttt{r} \rangle$, onde $0$ indica a distância até o início da
correspondência no \textit{search buffer}, $4$ indica o comprimento da
correspondência encontrada (\texttt{"abra"}), e \texttt{"r"} é o caractere
seguinte imediatamente após essa sequência, ainda não codificado. Após isso, a
janela avança em 5~posições (4~caracteres da sequência codificada mais
1~caractere literal).

Para realizar o processo inverso, ou seja, decodificar o token recebido
$\langle 0, 4, \texttt{r} \rangle$, o decodificador utiliza o mesmo princípio
do algoritmo LZ77, porém no sentido inverso.

Inicialmente, ele utiliza o pointer ($p$) para retornar exatamente 0 posições na
sequência já decodificada até o momento. A partir dessa posição inicial
encontrada, copia-se uma sequência de comprimento 4 (valor $l$), obtendo o
trecho \texttt{"abra"}. Em seguida, adiciona-se ao final desta sequência
copiada o caractere literal adicional ($c$), que neste exemplo é \texttt{"r"}.

Esse processo é ilustrado passo a passo na Figura~\ref{fig:Estado_deconding}.
Inicialmente, há o estado parcial da decodificação com o \textit{buffer} já
reconstruído. Em seguida, avança-se caractere a caractere, copiando-se do
\textit{buffer} reconstruído e adicionando o caractere literal no final. O
resultado final após a decodificação deste token será \texttt{"abrar"}.

Vale destacar que o decodificador reconstrói o buffer de busca dinamicamente,
conforme recebe e processa novos tokens, permitindo a reconstrução exata dos
dados originais sem perda alguma.

% Até Aqui

\begin{figure}[htp]
  \centering
  \caption{Decodificação do exemplo $\langle 7, 4, \texttt{r} \rangle$ }
  \label{fig:Estado_deconding}
  \includegraphics[width=12cm]{figuras/DiagramasTCC-LZ77-Decoding}
  \fonte{Adaptada de \textcite{sayood2012introduction}}
\end{figure}

Utilizando o exemplo anterior do token $\langle 7, 4, \texttt{r} \rangle$, onde
a janela total possui 13 caracteres, temos a seguinte definição dos campos em
bits:
\begin{itemize}
  \item O deslocamento ($p$) pode variar de 0 a 6, portanto requer $3$~bits;
  \item  O comprimento ($\ell$) pode variar de 0 a 7, logo exige também $3$~bits;
  \item O caractere literal ($c$) é codificado em ASCII, utilizando $8$~bits
        ($1$~byte).
\end{itemize}
Dado que na implementação adotada os tamanhos em bits para cada campo do token são
\[
  \underbrace{3}_{\substack{\text{bits para}\\\text{pointer }(p)}} +
  \underbrace{3}_{\substack{\text{bits para}\\\text{length }(\ell)}} +
  \underbrace{8}_{\substack{\text{bits para}\\\text{character }(x)}}
  = 14\;\text{bits},
\]
temos um formato de código de comprimento fixo, no qual cada token $\langle p,
  \ell, x\rangle$ ocupará exatamente 14 bits. Em outras palavras, após definido o
tamanho da janela (\textit{pointer}) e do \textit{lookahead buffer}
(\textit{length}), bem como o padrão de 8 bits para o caractere literal, toda e
qualquer codificação produzida por esse esquema terá comprimento contínuo de 14
bits por símbolo codificado \cite{nelson2008data}.

Realizando a codificação especificamente para o exemplo dado ($\langle 0, 4,
  \texttt{r} \rangle$), obtêm-se:
\begin{itemize}
  \item O valor do \textit{pointer} $o = 0$, em $3$ bits é $000_{(2)}$.
  \item O comprimento $l = 4$, em $3$ bits é $100_{(2)}$.
  \item O caractere $r$, em ASCII binário ($8$ bits), é $01110010_{(2)}$.
\end{itemize}
Portanto, a representação completa do token em bits será:
$$
  000 \;|\; 100 \;|\; 01110010
$$
Resultando na sequência binária final: $00010001110010_{(2)}$.

Esse processo ilustra o funcionamento fundamental do algoritmo LZ77, mostrando
como ele explora redundâncias por meio de correspondências encontradas em
trechos já codificados, reduzindo o volume de dados transmitidos ou
armazenados.

% Revisões Aqui
\newpage
\section{Biblioteca \textit{Komm}}

A \textit{Komm} é uma biblioteca em \textit{Python} voltada para o estudo e a
simulação de sistemas de comunicação, desenvolvida pelo professor Roberto
Nóbrega. Trata-se de um projeto \textit{open-source} compatível com
\textit{Python~3}, que fornece um conjunto de ferramentas voltadas tanto para
a análise teórica quanto para a implementação prática de técnicas clássicas e
modernas de comunicação digital.

A biblioteca adota uma filosofia fortemente inspirada em ferramentas
acadêmicas e industriais, como o
\textit{MATLAB\textsuperscript{\textregistered}
  Communications System Toolbox\texttrademark}, o
\textit{GNU Radio}, o \textit{CommPy} e o \textit{SageMath}. 
Contudo, diferencia-se dessas alternativas por priorizar uma abordagem
didática e modular, em que cada componente do sistema é modelado de forma
independente e parametrizável. Dessa maneira, a \textit{Komm} se consolida como
um ambiente unificado para ensino e pesquisa em comunicação, codificação de
fontes e teoria da informação.

\subsection{Estrutura e organização}

A arquitetura da \textit{Komm} é organizada em módulos temáticos que cobrem
diferentes aspectos dos sistemas de comunicação, incluindo: modulação,
codificação de canal, correção de erros, codificação de fonte e geração de
sinais. Cada módulo é projetado para ser independente, porém interoperável com
os demais, de modo que o usuário possa compor sistemas completos de
comunicação digital a partir de blocos básicos.

No contexto deste trabalho, o foco está no módulo de \textbf{codificação sem
perdas} (\textit{lossless coding}), responsável pela implementação de
algoritmos de compressão de dados baseados em dicionário e em códigos de
comprimento variável. Esse módulo disponibiliza atualmente os seguintes
esquemas de codificação:

\begin{itemize}
  \item \textbf{Shannon Code}: implementação baseada no princípio de
        entropia mínima para codificação por símbolos individuais;
  \item \textbf{Fano Code}: variante do método de Shannon–Fano com particionamento
        recursivo das probabilidades;
  \item \textbf{Huffman Code}: código ótimo de comprimento variável, usado como
        referência clássica em compressão sem perdas;
  \item \textbf{Lempel–Ziv 78 (LZ78)}: algoritmo incremental baseado em
        dicionário dinâmico;
  \item \textbf{Lempel–Ziv–Welch (LZW)}: extensão do LZ78 que remove o envio
        explícito de caracteres literais.
\end{itemize}

\subsection{Motivação educacional e integração}

A \textit{Komm} foi concebida não apenas como uma biblioteca de software, mas
também como uma ferramenta de apoio ao ensino e à experimentação. Sua
estrutura modular permite que estudantes explorem separadamente as etapas de
codificação, decodificação e análise de desempenho, favorecendo a compreensão
dos princípios de cada algoritmo.

Cada classe segue um padrão uniforme de interface, documentação e testes,
permitindo o uso consistente de diferentes algoritmos com a mesma estrutura de
chamada. Isso viabiliza comparações diretas entre métodos de compressão, tanto
em termos de eficiência quanto de complexidade computacional, o que é
particularmente útil em contextos acadêmicos.

\subsection{Relação com este trabalho}

A implementação do algoritmo \textit{Lempel–Ziv 77} (LZ77) desenvolvida neste
trabalho foi incorporada ao módulo de \textit{lossless coding} da biblioteca
\textit{Komm}. Essa contribuição amplia o conjunto de técnicas de compressão
disponíveis, completando a família de algoritmos \textit{Lempel–Ziv}.

Dessa forma, o presente trabalho se insere diretamente no propósito
pedagógico da \textit{Komm}: disponibilizar implementações abertas, documentadas e
 consistente em relação aos algoritmos clássicos de codificação de fonte,
permitindo ao mesmo tempo estudo teórico, análise experimental e integração
com outros componentes de sistemas de comunicação digital.
