\chapter{Desenvolvimento}\label{cap:desenvolvimento}

Este capítulo apresenta como foi o desenvolvimento dos módulos LZ77 e
codificação aritmética na biblioteca Komm. A liguagem escolhida foi Python, a
qual é utilizada na Komm

\section{Modulo LZ77}
Este seção descreve a implementação do algoritmo \textit{LZ77} na biblioteca
\textit{Komm}, detalhando o processo de projeto, integração e validação do
código. O objetivo é apresentar a contribuição prática deste trabalho,
demonstrando como o algoritmo foi estruturado e adaptado ao padrão da
biblioteca.

A biblioteca \textit{Komm} já dispõe de diversos algoritmos de compressão sem
perdas, como \textit{Huffman}, \textit{Tunstall}, \textit{Lempel-Ziv 78} (LZ78)
e \textit{Lempel-Ziv-Welch} (LZW). Entretanto, não havia uma implementação
disponível para o algoritmo \textit{Lempel-Ziv 77} (LZ77), que é um dos métodos
clássicos de compressão baseada em dicionário. Assim, a contribuição deste
trabalho consistiu no desenvolvimento completo do LZ77, incluindo:
\begin{itemize}
    \item Desenvolvimento das rotinas de codificação (\texttt{encode}) e decodificação
          (\texttt{decode}) baseadas em triplos $\langle o, l, c \rangle$;
    \item Integração com a estrutura da biblioteca \textit{Komm};
    \item Elaboração de testes unitários para validação da corretude.
    \item Documentação e padronização segundo o estilo da biblioteca;
\end{itemize}

\subsection{Arquitetura e Estrutura da Implementação}
A implementação foi organizada em um módulo denominado
\texttt{LempelZiv77Code.py}, composto pelas funções de \texttt{encode} e
\texttt{decode}, além de rotinas auxiliares responsáveis pela manipulação da
janela deslizante. O algoritmo segue a lógica clássica do LZ77, produzindo
trios $\langle o, l, c \rangle$, onde:
\begin{itemize}
    \item $o$ (\textit{offset}): deslocamento em relação ao início da correspondência encontrada no \textit{search buffer};
    \item $l$ (\textit{length}): comprimento da correspondência;
    \item $c$ (\textit{character}): próximo símbolo literal após a correspondência.
\end{itemize}
\begin{lstlisting}[language=Python, caption={Estrutura simplificada da classe LZ77}]
@dataclass
class LempelZiv77Code:
    source_cardinality: int
    target_cardinality: int
    window_size: int
    lookahead_size: int

    def encode(self, data):
        ...
    def decode(self, encoded_data):
        ...
\end{lstlisting}


Na inicialização, cálculos automáticos determinam a largura dos campos dos
triplos na base de destino ($T$), conforme:
\[
    D = \left\lceil \log_T(W+1) \right\rceil, \quad
    L_w = \left\lceil \log_T(L+1) \right\rceil, \quad
    M = \left\lceil \log_T(S) \right\rceil
\]
em que $W$ é o tamanho da janela deslizante (\textit{search buffer}), $L$ é o
tamanho do \textit{lookahead buffer} e $S$ é a cardinalidade do alfabeto da
fonte.


%\subsection{Abordagem Algorítmica e Otimizações}
%
%O núcleo do algoritmo envolve a busca do maior trecho repetido na janela deslizante antecedente ("search buffer"). Este trabalho inovou ao combinar busca por força bruta com otimização via hash table, acelerando a identificação de padrões curtos e frequentes, como detalhado abaixo:
%
%\begin{itemize}
%    \item \textbf{Busca por Hash Table:} Utiliza padrões fixos como chave de indexação; limitações de tamanho dos buckets garantem uso eficiente da memória.
%    \item \textbf{Fallback para Força Bruta:} Caso o hash não encontre correspondências relevantes, ocorre varredura tradicional garantindo compressão ótima.
%    \item \textbf{Suporte a Sobreposição (\textit{Overlap}):} Permite que triplos referenciem trechos em sobreposição, expandindo o potencial de compressão, conforme descrito na literatura.
%\end{itemize}
%Esse modelo garante alto desempenho sem sacrificar a compressão em sequências complexas.

\section{Estrutura Modular do Algoritmo}

Com o intuito de tornar a implementação não apenas funcional, mas também de
caráter educacional, o algoritmo LZ77 foi dividido em quatro módulos
principais: dois referentes à etapa de \textit{encode} e dois referentes à
etapa de \textit{decode}. Essa divisão tem como objetivos:

\begin{itemize}
    \item \textbf{Clareza pedagógica:} permite visualizar separadamente cada fase do processo, facilitando o entendimento para estudantes e pesquisadores iniciantes na área de compressão de dados.
    \item \textbf{Comparação com a literatura:} possibilita acompanhar resultados parciais que correspondem a descrições tradicionais encontradas em materiais de referência, mas que geralmente não apresentam uma implementação prática em código.
    \item \textbf{Visualização dos resultados:} oferece uma camada adicional para inspecionar a saída intermediária, permitindo a análise tanto em nível conceitual quanto em nível binário, aspecto pouco explorado em outras implementações.
\end{itemize}

Os módulos estão organizados da seguinte forma:
\begin{enumerate}
    \item \textbf{Codificação:}
          \begin{itemize}
              \item \texttt{source\_to\_triples}: identificação dos triplos $\langle o, l, c \rangle$ a partir da sequência de entrada;
              \item \texttt{triples\_to\_target}: conversão dos triplos para o fluxo no alfabeto de saída (base $T$).
          \end{itemize}
    \item \textbf{Decodificação:}
          \begin{itemize}
              \item \texttt{target\_to\_triples}: reconstrução dos triplos a partir do fluxo no alfabeto de saída;
              \item \texttt{triples\_to\_source}: recuperação da mensagem original no alfabeto de entrada.
          \end{itemize}
\end{enumerate}

Essa abordagem modular é inédita dentro da biblioteca \textit{Komm} e busca
proporcionar não apenas uma ferramenta prática, mas também um recurso didático
útil para disciplinas de Teoria da Informação, Compressão de Dados e Sistemas
de Comunicação.

\subsection{Abordagem Algorítmica}

O núcleo do algoritmo envolve a busca do maior trecho coincidente no
\textit{search buffer}, usando uma janela deslizante de tamanho $W$ e um
\textit{lookahead buffer} de tamanho $L$. Foram adotadas as seguintes
estratégias:
\begin{itemize}
    \item \textbf{Busca incremental:} varredura que tenta estender o comprimento $l$ enquanto a correspondência se mantém válida;
    \item \textbf{Tratamento de sobreposição (overlap):} permissivo à referência de trechos parcialmente sobrepostos, preservando a corretude;
    \item \textbf{Limites de janela:} garantias de que $o \leq W$ e $l \leq L$ em todas as emissões de triplos.
\end{itemize}


\subsection{Integração do modulo Lz77 com a Biblioteca Komm}
A classe \texttt{LempelZiv77Code} foi integrada ao padrão da \textit{Komm},
respeitando assinatura de métodos, tratamento de exceções e estilo de
documentação. Isso garante que o usuário final possa utilizá-la de modo análogo
aos demais códigos de fonte-canal presentes na biblioteca.
\begin{lstlisting}[language=Python, caption={Exemplo de uso do LZ77 integrado à Komm}]
lz77 = LempelZiv77Code(
    source_cardinality=5,
    target_cardinality=2,
    window_size=13,
    lookahead_size=6
)
encoded = lz77.encode([2,0,1,4,2,0,1, ...])
decoded = lz77.decode(encoded)
assert decoded == [2,0,1,4,2,0,1, ...]
\end{lstlisting}

\section{Testes e Validação}
Foram implementados testes unitários (\texttt{test\_lz77.py}) cobrindo:
\begin{itemize}
    \item Casos simples com sequências curtas;
    \item Cadeias altamente redundantes;
    \item Piores casos para compressão (baixa redundância);
    \item Exemplos extraídos da literatura técnica.
\end{itemize}

A validação principal utiliza testes de ida-e-volta (\textit{round trip}):
\texttt{decode(encode(x)) == x}. Adicionalmente, as saídas intermediárias
(triplos e fluxo no alfabeto de destino) são verificadas para garantir
consistência com os parâmetros $(W, L, S)$ e com as larguras de campo $\{D,
    L_w, M\}$.

%\section{Resultados e Discussão}
%Para validar o desempenho do algoritmo, foram comparados os resultados da compressão de diferentes cadeias com outros algoritmos já presentes na biblioteca.  
%O LZ77 apresentou bons resultados em sequências redundantes, embora o overhead do trio $\langle o, l, c \rangle$ limite a eficiência em cadeias pequenas ou sem repetições.  
%Ainda assim, sua implementação é um marco importante, pois serve de base para extensões futuras, como os algoritmos LZSS, LZ78 e LZW, ampliando o repertório da biblioteca \textit{Komm}.
